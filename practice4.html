<!doctype html>
<html lang="en">
    <head>
 <style>
    .demo{
        color: 'red'
    }
    .blue {
        background-color: blue;
    }
 </style>
    </head>

    <body>
        <table border="2">
            <!-- <thead class="thead-dark"> -->
              <tr>
                <th scope="col">Tour</th>
                <th scope="col">Day</th>
                <th scope="col">Time</th>
              </tr>
            <!-- </thead> -->
            <tbody id="tableBody">
                                              
            </tbody>
          </table>
          <div id="myDynamicTable"></div>
        <header>
            <!-- place navbar here -->
        </header>
        <script>
          const Google = {
	locations:['Mountain View','New York','London']
}

const {locations:[name, test]} = Google
console.log('location>>> ',name, test)//result: Mountain View
          var productsS = [
    {name: 'cucumber', type: 'vegetable'},
    {name: 'banana', type: 'fruit'},
    {name: 'celery', type: 'vegetable'},
    {name: 'orange', type: 'fruit'}
]

let me = productsS.filter(product => {
  return product.type === 'fruit'
}).map(({name})=>({name}))
console.log('MEMEME>> ', me);
              const products = [{
  "id": "111",
  "name": "grapes",
  "status": "Linked",
}, {
  "id": "222",
  "name": "banana",
  "status": "Existing",
}, {
  "id": "333",
  "name": "mango",
  "status": "Existing",
}, {
  "id": "444",
  "name": "salad",
  "status": "Linked",

}, {
  "id": "555",
  "name": "juice",
  "status": "Existing",
}];
const resust3 = products.filter(item=> {
  return item.status =="Existing"
}).map(item=> {
  return item.name 
})
console.log('resust3>>>',resust3 );
resust3.forEach((item, index)=> {
                if(item=="banana"){
                  resust3[index] = "BANA"
                }else if(item =="juice"){
                  resust3[index] = "ORANGE"
                }
        //  resust3[index]= item.includes('banana') ? 'BANA' : item
})
console.log('resust3resust3>>>', resust3);
//  resust3.forEach((item, index)=> {
//              item.age = (item.id == "555" ? 65 : item.id)
//              item.supersalad = (item.status == "Existing" ? 'great salad' : item.name)
//  })
//  console.log('supersalad>>>',resust3 );
//https://stackoverflow.com/questions/72356724/efficient-way-of-filtering-array-and-mapping-in-es6
// const result = products.filter(({status}) => status === 'Existing')
//                        .map(({id, name}) => ({id, name}));

display =[]
const result = products.filter(item=> {
            let html =   document.createElement('div')
            html.setAttribute('id', 'demo')
                html.style.background = 
                item.name =="juice" ? 'red'
                : item.name=="salad" ? 'blue'
                : item.name =="mango" ? 'yellow':"cyan"
                // item ?? "Another way"
                html.innerHTML = item.name
                html.classList.add('.demo')
                display.push(html)
 
})


display.forEach(element => {
    document.body.appendChild(element)
});

console.log('html>>>', display);       
console.log('RESUTT>>>', result);
///////////////////////////////////////////////////////////////////////
const data = [
    {Name:'Sydney', Day: 'Monday', Time: '10:00AM'},
    {Name:'New York', Day: 'Monday',Time: '11:00AM'},
]; // any json data or array of objects

const tableData = data.map(value => {
 return (
  `<tr>
        <td>${value.Name}</td>
        <td>${value.Day}</td>
        <td>${value.Time}</td>
    </tr>
  `
 )

})

const tableBody = document.querySelector("#tableBody");
tableBody.innerHTML = tableData;
///////////////////////////////////////////////////////////
function addTable() {
  data.forEach((item, index)=> {
    var myTableDiv = document.getElementById("myDynamicTable");

var table = document.createElement('TABLE');
table.border = '1';
table.style.color = 'red'
table.setAttribute('id', 'mike')
table.setAttribute('class', 'blue')
table.classList.add('blue')

var tableBody = document.createElement('TBODY');
table.appendChild(tableBody);

for (var i = 0; i < 3; i++) {
  var tr = document.createElement('TR');
  tableBody.appendChild(tr);

  for (var j = 0; j < 4; j++) {
    var td = document.createElement('TD');
    td.width = '75';
    td.appendChild(document.createTextNode(`${item.Name} ${item.Day}`));
    tr.appendChild(td);
  }
}
myTableDiv.appendChild(table);
  })

}
addTable();
////////////////////////////
var h1 = document.createElement('h1')
    h1.innerHTML ='Welcome'
    document.body.appendChild(h1)
var cssApply = document.getElementsByTagName('h1')[0]
console.log('cssApply>> ', cssApply);
    cssApply.classList.add('blue')
    //////////////////////////////////
var btn = document.createElement('button');
btn.innerHTML = "Create Table";
document.body.appendChild(btn);
btn.addEventListener("click", createTable, true);
function createTable(){
var div = document.createElement('div');
div.setAttribute("id", "tbl");
div.setAttribute('class', 'testing')
document.body.appendChild(div)
	document.getElementById("tbl").innerHTML = "<table border = '1'>" +
  '<tr>' +
    '<th>Header 1</th>' +
    '<th>Header 2</th> ' +
    '<th>Header 3</th>' +
  '</tr>' +
  '<tr>' +
    '<td>Data 1</td>' +
    '<td>Data 2</td>' +
    '<td>Data 3</td>' +
  '</tr>' +
  '<tr>' +
    '<td>Data 1</td>' +
    '<td>Data 2</td>' +
    '<td>Data 3</td>' +
  '</tr>' +
  '<tr>' +
    '<td>Data 1</td>' +
    '<td>Data 2</td>' +
    '<td>Data 3</td>' +
  '</tr>' 
  ///Use can use string backtick assign == document.getElementById("tbl").innerHTML above table below
//   `<table style="width:100%">
//   <tr>
//     <th>Company</th>
//     <th>Contact</th>
//     <th>Country</th>
//   </tr>
//   <tr>
//     <td>Alfreds Futterkiste</td>
//     <td>Maria Anders</td>
//     <td>Germany</td>
//   </tr>
//   <tr>
//     <td>Centro comercial Moctezuma</td>
//     <td>Francisco Chang</td>
//     <td>Mexico</td>
//   </tr>
// </table>
//   `
};
        </script>
   
    </body>
</html>

========================================================
import { Component, OnInit } from '@angular/core';
// Assuming you have a service like this for the URL
// import { WindowService } from './window.service';

interface CardContent {
  id: string; // Added an ID for easier selection
  title: string;
  description: string;
  href: string;
  navText: string;
}

@Component({
  selector: 'app-info-card',
  templateUrl: './info-card.component.html',
  styleUrls: ['./info-card.component.css']
})
export class InfoCardComponent implements OnInit {

  // --- Your Conditions (replace with your actual logic) ---
  userHasRecurringTransfer: boolean = false;
  userReachedMaxContribution: boolean = false;
  // ---

  cardsContent: CardContent[] = [
    {
      id: 'setup-recurring',
      title: 'You haven\'t set up a recurring transfer',
      description: 'Adding money regularly can help you meet your goal. Plus, putting it on automatic means one less thing to...',
      // Use the actual service method to get the full URL if needed
      href: '/ftgw/digital/transfer/', // Example relative path
      navText: 'Set up a transfer',
    },
    {
      id: 'has-recurring',
      title: 'You\'ve set up a recurring transfer - great job!',
      description: 'If there could be a gap between what you plan to invest and your goal, there\'s always an option to add a...',
      href: '/ftgw/digital/transfer/', // Example relative path
      navText: 'Make a one-time transfer',
    },
    {
      id: 'max-contribution',
      title: 'You\'ve contributed the maximum amount for the year',
      description: 'Don\'t let that stop your investing momentum! Check out some of Fidelity Go\'s other account types.',
      href: 'https://www.fidelity.com/managed-accounts/fidelity-go', // Example absolute path
      navText: 'Learn more',
    }
  ];

  cardToDisplay: CardContent | undefined; // Variable to hold the selected card

  // Inject services like WindowService if needed for URL generation
  // constructor(private windowService: WindowService) {}
  constructor() {}

  ngOnInit(): void {
    this.selectCard();
  }

  selectCard(): void {
    if (this.userReachedMaxContribution) {
      this.cardToDisplay = this.cardsContent.find(card => card.id === 'max-contribution');
    } else if (this.userHasRecurringTransfer) {
      this.cardToDisplay = this.cardsContent.find(card => card.id === 'has-recurring');
    } else {
      this.cardToDisplay = this.cardsContent.find(card => card.id === 'setup-recurring');
    }

    // Optional: Resolve relative URLs here if needed using your service
    // if (this.cardToDisplay && this.cardToDisplay.href.startsWith('/')) {
    //   this.cardToDisplay.href = this.windowService.getDigitalHostUrl(this.cardToDisplay.href);
    // }
  }

  // Example function to simulate changing conditions
  simulateSettingRecurringTransfer(hasTransfer: boolean): void {
    this.userHasRecurringTransfer = hasTransfer;
    this.userReachedMaxContribution = false; // Ensure other conditions might reset
    this.selectCard();
  }
}
===============================================
<div *ngIf="cardToDisplay" class="card"> <h2>{{ cardToDisplay.title }}</h2>
  <p>{{ cardToDisplay.description }}</p>
  <a [href]="cardToDisplay.href" target="_blank" rel="noopener noreferrer">
    {{ cardToDisplay.navText }}
  </a>
  </div>

<button (click)="simulateSettingRecurringTransfer(false)">Simulate No Recurring Transfer</button>
<button (click)="simulateSettingRecurringTransfer(true)">Simulate Has Recurring Transfer</button>
=========
cardsContent: CardContentDisplay[] = [
    {
      id: 'setup-recurring-transfer',
      title: 'You haven’t set up a recurring transfer',
      description:
        'Adding money regularly can help you meet your goal. Plus, putting it on automatic means one less thing to do!',
      href: this.windowService.getDigitalHostUrl(`/ftgw/digital/transfer/`),
      navText: 'Set up a transfer',
    },
    {
      id: 'has-recurring-transfer',
      title: 'You’ve set up a recurring transfer—great job!',
      description:
        'If there could be a gap between what you plan to invest and your goal, there’s always an option to add a little more.',
      href: this.windowService.getDigitalHostUrl(`/ftgw/digital/transfer/`),
      navText: 'Make a one-time transfer',
    },
    {
      id: 'contribution-maximum',
      title: 'You’ve contributed the maximum amount for the year',
      description:
        'Don’t let that stop your investing momentum! Check out some of Fidelity Go’s other account types.',
      href: 'https://www.fidelity.com/managed-accounts/fidelity-go',
      navText: 'Learn more',
    },
  ];
  cardToDisplay: CardContentDisplay;

  ngOnInit(): void {
    this.selectCardDisplay();
  }
  selectCardDisplay(): void {
    if (this.isRecurringTransfer) {
      this.cardToDisplay = this.cardsContent.find(
        (card) => card.id === 'contribution-maximum'
      );
    } else if (this.isRecurringTransfer) {
      this.cardToDisplay = this.cardsContent.find(
        (card) => card.id === 'has-recurring-transfer'
      );
    } else {
      this.cardToDisplay = this.cardsContent.find(
        (card) => card.id === 'setup-recurring-transfer'
      );
    }
  }
========================================================



Let's write unit tests for this Angular component using Jasmine and Angular's testing utilities. First, I'll note that there seems to be a logic error in the `selectCardDisplay()` method - it has two identical `if (this.isRecurringTransfer)` conditions, which means the second condition will never execute. I'll assume one should check for a different condition (perhaps `hasReachedMaxContribution`) and write tests accordingly.

Here's a complete unit test suite:

```typescript
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { Component } from '@angular/core';
import { WindowService } from './window.service'; // Assuming this is the service's path

// Define the interface (you might already have this in a separate file)
interface CardContentDisplay {
  id: string;
  title: string;
  description: string;
  href: string;
  navText: string;
}

// Mock WindowService
class MockWindowService {
  getDigitalHostUrl(path: string): string {
    return `https://mock-digital-host${path}`;
  }
}

@Component({
  selector: 'app-test-component',
  template: ''
})
class TestComponent {
  constructor(private windowService: WindowService) {}

  cardsContent: CardContentDisplay[] = [
    {
      id: 'setup-recurring-transfer',
      title: 'You haven’t set up a recurring transfer',
      description: 'Adding money regularly can help you meet your goal. Plus, putting it on automatic means one less thing to do!',
      href: this.windowService.getDigitalHostUrl(`/ftgw/digital/transfer/`),
      navText: 'Set up a transfer',
    },
    {
      id: 'has-recurring-transfer',
      title: 'You’ve set up a recurring transfer—great job!',
      description: 'If there could be a gap between what you plan to invest and your goal, there’s always an option to add a little more.',
      href: this.windowService.getDigitalHostUrl(`/ftgw/digital/transfer/`),
      navText: 'Make a one-time transfer',
    },
    {
      id: 'contribution-maximum',
      title: 'You’ve contributed the maximum amount for the year',
      description: 'Don’t let that stop your investing momentum! Check out some of Fidelity Go’s other account types.',
      href: 'https://www.fidelity.com/managed-accounts/fidelity-go',
      navText: 'Learn more',
    },
  ];

  cardToDisplay: CardContentDisplay;
  isRecurringTransfer: boolean = false;
  // Adding this property since the original code seems to have a logic error
  hasReachedMaxContribution: boolean = false;

  ngOnInit(): void {
    this.selectCardDisplay();
  }

  selectCardDisplay(): void {
    // Corrected logic assuming this is what was intended
    if (this.hasReachedMaxContribution) {
      this.cardToDisplay = this.cardsContent.find(
        (card) => card.id === 'contribution-maximum'
      );
    } else if (this.isRecurringTransfer) {
      this.cardToDisplay = this.cardsContent.find(
        (card) => card.id === 'has-recurring-transfer'
      );
    } else {
      this.cardToDisplay = this.cardsContent.find(
        (card) => card.id === 'setup-recurring-transfer'
      );
    }
  }
}

describe('TestComponent', () => {
  let component: TestComponent;
  let fixture: ComponentFixture<TestComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [TestComponent],
      providers: [
        { provide: WindowService, useClass: MockWindowService }
      ]
    }).compileComponents();
  });

  beforeEach(() => {
    fixture = TestBed.createComponent(TestComponent);
    component = fixture.componentInstance;
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should display setup-recurring-transfer card when no recurring transfer and no max contribution', () => {
    component.isRecurringTransfer = false;
    component.hasReachedMaxContribution = false;
    fixture.detectChanges(); // Triggers ngOnInit

    expect(component.cardToDisplay.id).toBe('setup-recurring-transfer');
    expect(component.cardToDisplay.title).toBe('You haven’t set up a recurring transfer');
  });

  it('should display has-recurring-transfer card when recurring transfer is set but not at max contribution', () => {
    component.isRecurringTransfer = true;
    component.hasReachedMaxContribution = false;
    fixture.detectChanges();

    expect(component.cardToDisplay.id).toBe('has-recurring-transfer');
    expect(component.cardToDisplay.title).toBe('You’ve set up a recurring transfer—great job!');
  });

  it('should display contribution-maximum card when max contribution is reached', () => {
    component.isRecurringTransfer = true;
    component.hasReachedMaxContribution = true;
    fixture.detectChanges();

    expect(component.cardToDisplay.id).toBe('contribution-maximum');
    expect(component.cardToDisplay.title).toBe('You’ve contributed the maximum amount for the year');
  });

  it('should initialize cardsContent with correct href values using WindowService', () => {
    expect(component.cardsContent[0].href).toBe('https://mock-digital-host/ftgw/digital/transfer/');
    expect(component.cardsContent[1].href).toBe('https://mock-digital-host/ftgw/digital/transfer/');
    expect(component.cardsContent[2].href).toBe('https://www.fidelity.com/managed-accounts/fidelity-go');
  });

  it('should call selectCardDisplay on initialization', () => {
    spyOn(component, 'selectCardDisplay');
    fixture.detectChanges();
    expect(component.selectCardDisplay).toHaveBeenCalled();
  });
});
```

This test suite includes:

1. A mock `WindowService` since the original code depends on it
2. A test component with corrected logic (assuming the duplicate condition was a mistake)
3. Setup with TestBed configuration
4. Basic component creation test
5. Tests for each card display scenario
6. Test for proper href value initialization
7. Test for ngOnInit behavior

Key points about the tests:

- They verify the component's core functionality of selecting the appropriate card based on conditions
- They check that the component initializes properly
- They validate the dependency injection with WindowService
- They use spies to verify method calls
- They test all possible paths in the `selectCardDisplay()` method

Note: I had to make some assumptions:
1. Added `hasReachedMaxContribution` property since the original code's logic seemed incorrect
2. Assumed the existence of a `WindowService` with a `getDigitalHostUrl` method
3. Created a basic component structure since the full component context wasn't provided

You might need to adjust the import paths, service mock, and property names based on your actual project structure and requirements.
